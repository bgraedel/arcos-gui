{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#arcos-gui","title":"arcos-gui","text":"<p>A napari plugin to detect and visualize collective signaling events</p> <ul> <li>Package specific Documentation: https://bgraedel.github.io/arcos-gui</li> <li>ARCOS documentation: https://arcos.gitbook.io</li> </ul> <p>Automated Recognition of Collective Signalling (ARCOS) is an algorithm to identify collective spatial events in time series data. It is available as an R (ARCOS) and python (arcos4py) package. ARCOS can identify and visualize collective protein activation in 2- and 3D cell cultures over time.</p> <p>This plugin integrates ARCOS into napari. Users can import tracked time-series data in CSV format or load data from napari-layer properties (such as the ones generated with napari-skimage-regionprops. The plugin provides GUI elements to process this data with ARCOS. Layers containing the detected collective events are subsequently added to the viewer.</p> <p>Following analysis, the user can export the output as a CSV file with the detected collective events or as a sequence of images to generate a movie.</p> <p></p> <p>Watch full demo on youtube (older plugin version)</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>arcos-gui</code> via pip:</p> <pre><code>pip install arcos-gui\n</code></pre> <p>Or via conda-forge:</p> <pre><code>conda install -c conda-forge arcos-gui\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The plugin can be started from the napari menu <code>Plugins &gt; ARCOS GUI</code>. For detailed instructions on how to use the plugin, please refer to the Usage section of the documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are very welcome. Tests can be run with tox, please ensure the coverage at least stays the same before you submit a pull request. See the Contributing Guide for more information.</p>"},{"location":"#license","title":"License","text":"<p>Distributed under the terms of the BSD-3 license, \"arcos-gui\" is free and open-source software</p>"},{"location":"#issues","title":"Issues","text":"<p>If you encounter any problems, please file an issue along with a detailed description.</p>"},{"location":"#credits","title":"Credits","text":"<p>We were able to develop this plugin in part due to funding from the CZI napari Plugin Foundation Grant.</p> <p>This napari plugin was generated with Cookiecutter using @napari's cookiecutter-napari-plugin template.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this plugin in your research, please cite the following paper:</p> <pre><code>@article{10.1083/jcb.202207048,\n    author = {Gagliardi, Paolo Armando and Gr\u00e4del, Benjamin and Jacques, Marc-Antoine and Hinderling, Lucien and Ender, Pascal and Cohen, Andrew R. and Kastberger, Gerald and Pertz, Olivier and Dobrzy\u0144ski, Maciej},\n    title = \"{Automatic detection of spatio-temporal signaling patterns in cell collectives}\",\n    journal = {Journal of Cell Biology},\n    volume = {222},\n    number = {10},\n    pages = {e202207048},\n    year = {2023},\n    month = {07},\n    abstract = \"{Increasing experimental evidence points to the physiological importance of space\u2013time correlations in signaling of cell collectives. From wound healing to epithelial homeostasis to morphogenesis, coordinated activation of biomolecules between cells allows the collectives to perform more complex tasks and to better tackle environmental challenges. To capture this information exchange and to advance new theories of emergent phenomena, we created ARCOS, a computational method to detect and quantify collective signaling. We demonstrate ARCOS on cell and organism collectives with space\u2013time correlations on different scales in 2D and 3D. We made a new observation that oncogenic mutations in the MAPK/ERK and PIK3CA/Akt pathways of MCF10A epithelial cells hyperstimulate intercellular ERK activity waves that are largely dependent on matrix metalloproteinase intercellular signaling. ARCOS is open-source and available as R and Python packages. It also includes a plugin for the napari image viewer to interactively quantify collective phenomena without prior programming experience.}\",\n    issn = {0021-9525},\n    doi = {10.1083/jcb.202207048},\n    url = {https://doi.org/10.1083/jcb.202207048},\n    eprint = {https://rupress.org/jcb/article-pdf/222/10/e202207048/1915749/jcb/_202207048.pdf},\n}\n</code></pre>"},{"location":"Contributing/","title":"Contributing","text":""},{"location":"Contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"Contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"Contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bgraedel/arcos-gui/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"Contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"Contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"Contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bgraedel/arcos-gui/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project and that contributions are welcome :)</li> </ul>"},{"location":"Contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>arcos-gui</code> for local development.</p> <ol> <li>Fork the <code>arcos-gui</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>git clone git@github.com:your_name_here/arcos-gui.git\n</code></pre> </li> <li> <p>Install dependencies and arcos-gui:</p> <p><pre><code>pip install napari[all]\npip install -e .[testing]\n</code></pre> If you are using conda for virtual environments, consider installing tox-conda.</p> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>tox\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"Contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.8, 3.9, and 3.10. Check    https://github.com/bgraedel/arcos-gui/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"Contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy:</p> <ul> <li>Change version numbers in \"init.py\" and \"setup.cfg\".</li> <li>Make sure all your changes are committed.</li> <li>Create a version tag. The tag will be used as the version string for your package.</li> </ul> <p>make it meaningful: https://semver.org/ <pre><code>git tag -a v0.1.0 -m \"v0.1.0\"\n\n# make sure to use follow-tags so that the tag also gets pushed to GitHub\ngit push --follow-tags\n</code></pre></p> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#installation","title":"Installation","text":"<p>If napari is not yet installed, install it with pip:</p> <pre><code>pip install napari[all]\n</code></pre> <p>It is better to do this in a new virtual environment to avoid dependency issues.</p> <p>If you don't have python or pip installed checkout anaconda/miniconda or this Python installation guide which can guide you through the process.</p> <p>After successfully installing napari, you can install <code>arcos-gui</code> via pip:</p> <pre><code>pip install arcos-gui\n</code></pre> <p>This is the preferred method to install arcos-gui, as it will always install the most recent stable release.</p> <p>To install the most recent development version :</p> <pre><code>pip install git+https://github.com/bgraedel/arcos-gui.git\n</code></pre>"},{"location":"Usage/","title":"Usage","text":""},{"location":"Usage/#usage","title":"Usage","text":"<p>The following section shows how to use arcos-gui.</p>"},{"location":"Usage/#open-main-widget-load-data-and-run-arcos","title":"Open Main Widget, Load Data, and run ARCOS","text":""},{"location":"Usage/#open-widget","title":"Open Widget","text":"<p>Make sure the arcos-gui and napari are installed.</p> <ol> <li>Open napari and dock the ARCOS main widget:</li> </ol> <p></p>"},{"location":"Usage/#load-data","title":"Load Data","text":"<ol> <li>Tabs represent different steps taken during the processing. Select the \"Input Data\" Tab to load a CSV file.</li> </ol> <p>2. Open the file browser by clicking on the folder icon and select CSV file with data in long format.     CSV file can be either comma, semicolon or tab separated. Additionally, arcos-gui supports loading csv.gz files. Then press the \"Load Data\" button. Additionally, you can also load data from layers that have properties attached to them. To do this, select the layer in the viewer and press the \"Load Data\" button. This will load the data from the layer and fill in the corresponding fields in the widget. Multiple layers can be selected simulataneously. This will then try to merge the data on a frame and labels column. If a trackslayer is present, this can be selected in the corresponding drop-down menu. The tracks layer is merged to the layer properties data. To generate a layer containing such data, use a widget such as the  napari plugin. This allows you to measure properties of regions in an image and add them to the properties of a layer.</p> <ol> <li> <p>In the popup dialogue, select columns corresponding to the indicated label. \"Z-coordinates\", \"Position\" and \"Additional Filter\" (e.g Well) can be None if this column does not exist.     Optionally the measurement used for detecting events can be calculated from two different columns i.e for Ratios of fluorescent biosensors). Depending on the selection of the operation via radio buttons,     an additional column can be specified as a second measurement. The default is None.</p> </li> <li> <p>Optional: Filter input data. Parameters can be used to select track length, rescale frame interval and rescale measurement.</p> </li> </ol>"},{"location":"Usage/#run-arcos","title":"Run ARCOS","text":"<p>Once data is loaded you can select the \"ARCOS Parameters\" Tab.</p> <p></p> <ol> <li> <p>Toggle if you want to interpolate your measurement column and if you want to clip your measurement values.</p> </li> <li> <p>Change Binarization parameters, by default no detrending is used. Advanced options allows showing alternative binarization methods and detrending methods.</p> </li> <li> <p>\"Binarize Data\" runs only the binarization process. This can be useful if the collective event detection takes a while. As well as to speed up the process of optimizing the binarization step.</p> </li> <li> <p>Change the Collective event detection parameters. By default, only Min Cluster Size is shown. This is the minimum number of objects that need to be within a certain range to be considered a cluster. As a rule of thumb, this can be set to the number of dimensions +1, so for 2D data, a starting value can be 3. But optimizing this parameter can lead to better event detection. By default, the Neighbourhood Size considered for clustering is estimated. See the Advanced options for more details or hover over individual parameters to get tooltips about individual settings.</p> </li> <li> <p>Update ARCOS. Will run the algorithm and generate layers.</p> </li> </ol>"},{"location":"Usage/#advanced-options","title":"Advanced Options","text":""},{"location":"Usage/#binarization-options","title":"Binarization Options","text":"<ul> <li> <p>Bias Method: Choice of binarization/detrending method. Currently available are none, runmed and lm.</p> <ul> <li> <p>None rescale the measurement globally. Values above Bin Threshold are selected as \"active\".</p> </li> <li> <p>Runmed applies a rolling median filter with size Bias K to individual tracks, to estimate the global trends in the individual objects. As a rule of thumb, Bias K should approximately cover 1/4 of the length of the time series. This is then subtracted from measurement and subsequently, tracks that have values above the \"Bin Peak Threshold\" are rescaled between 0 and 1. Values above Bin Threshold are selected as \"active\". This method works best for longer time series since a rather large median filter size is required to get an accurate estimation of a global trend.</p> </li> <li> <p>lm fits a polynomial of degree PolyDeg to all tracks and then uses this to estimate global trends in tracks. This is then subtracted from measurement and subsequently, tracks that have values above Bin Peak Threshold are rescaled between 0 and 1. Values above Bin Threshold are selected as \"active\".</p> </li> </ul> </li> <li> <p>Smooth K: Intended as a median filter with a small kernel size to remove local noise from the time series. If set to 1, no smoothing is applied.</p> </li> <li> <p>Bias K: Size of the median filter used for Runmed detrending</p> </li> <li> <p>Bin Peak Threshold: Threshold value used to pick measurement tracks that will be rescaled to the (0,1) range. If set to 0, all will be rescaled.</p> </li> <li> <p>PolyDeg: Degree of the polynom used in lm detrending.</p> </li> </ul>"},{"location":"Usage/#collective-event-detection-options","title":"Collective Event Detection Options","text":"<ul> <li> <p>Estimate Neighbourhood Size: Tries to estimate an optimal value for the Neighbourhood Size parameter. Options are mean, kneepoint, manual.</p> <ul> <li> <p>Mean: Calculates 1.5 times the average N nearest neighbour distance between all objects in the currently loaded data. N corresponds here to the Min Cluster Size paramter.</p> </li> <li> <p>Kneepoint: Calculates the knee of the sorted N nearest neighbour distance between all \"active\" (as determined by binarization) objects. The knee in this case would correspond to the point where the distribution of nearest neighbours changes drastically i.e </p> </li> <li> <p>Manual: Manually set eps to optimize event detection. A good strategy can be to try Neighbourhood estimation first and then fin-tune using Manual.</p> </li> </ul> </li> <li> <p>Neighbourhood Size: This is the maximum distance between two binarized objects for one to be considered as in the neighbourhood of the other. This is not a maximum bound on the distances of points within a collective event. I.e. if this value is larger the cluster will increase in size and potentially objects that should not be part of an event will be added. If it is too small no events will be detected. See DBSCAN for more details on the clustering method used in ARCOS and its parameter.</p> </li> <li> <p>Cluster Linking Distance: This is the distance used when tracking clusters through the time series. We found that setting this to the same value as Neighbourhood Size often results in good cluster linking. By default, this is the case in the napari plugin. If needed by checking the box next to the label, a separate value can be used to link frames together.</p> </li> </ul> <p>Min Cluster Size: Minimum number of binarized objects required around an object for it to be considered as a core of a cluster. See DBSCAN for more details.</p> <p>nPrev Frames: This parameter denotes of many previous frames are considered when linking clusters across the time series. In most cases, 1 should be good enough.</p>"},{"location":"Usage/#output-layers","title":"Output Layers","text":"<ol> <li>Widget</li> <li> <p>Detected collective event with its convex hull.</p> </li> <li> <p>Layers that the plugin adds are:</p> <ul> <li>All Cells: Centroid of cells with the colour code representing the measurement.</li> <li>Active cells: Black points represent active cells according to binarization</li> <li>Collective Events Cells: Points marking cells that are part of a collective event, coloured by collective event id.</li> <li>Collective Event: the convex hull of collective events, coloured by collective event id.</li> </ul> </li> </ol>"},{"location":"Usage/#additional-functionality","title":"Additional Functionality","text":""},{"location":"Usage/#layer-properties","title":"Layer Properties","text":"<ol> <li>This widget allows for adjustments to various layer properties related to the visualization of the ARCOS input and output data.</li> </ol>"},{"location":"Usage/#plots","title":"Plots","text":"<p>Under the widgets \"Plots\" tab, several types of plots can be found that describe the time-series data and collective events. Plots can be saved as images by clicking the \"Save\" button in the respective plot toolbar. Exporting as SVG is the best option in most cases.</p> <p></p> <ul> <li> <p>These plots help to choose appropriate parameters for ARCOS and track length filtering.     Plots are chosen through dropdown menus.     Available plots are:</p> <ul> <li> <p>Track length Histogram</p> <p>Plots a histogram of object track lengths in the source data.</p> </li> <li> <p>Measurement Density plot</p> <p>This plot shows the density distribution of the original measurement value that was selected in the column picker. The density is calculated using a kernel density estimation algorithm (KDE).</p> </li> <li> <p>Measurement Density plot (rescaled)</p> <p>This plot shows the density distribution of the rescaled measurement value as calculated during the binarization step. The density is calculated using a kernel density     estimation algorithm (KDE).</p> </li> <li> <p>Original vs Rescaled measurement</p> <p>The Original vs Rescaled plot shows the rescaled and detrended signal of a random object. To choose another random object, the \"Update Plot\" button can be pressed. In addition by selecting the \"All Cells\" layer in the viewer and using the selection tool to click on individual points, the corresponding signals are plotted, with an indication in red of which part of the time series was detected as being active.</p> </li> <li> <p>X-T and Y-T plot</p> <p>These two plots project the tracks in the filtered data on one axis and have the time on the other. This allows us to check the quality of the tracking to a certain extent.</p> </li> </ul> </li> </ul> <p>2. These plots are both interactive and allow users to explore the ARCOS output more in-depth. The respective plot can be selected from the corresponding tab. Available plots are:</p> <ul> <li> <p>Collev Plot:</p> <p>Interactive Scatterplot of duration vs size of Collective events.     On hover, shows the collective event id, and on click takes the user to the first frame of the selected collective event and marks this event with a bounding box.</p> </li> <li> <p>Noodle Plot:</p> <p>Interactive Noodleplot of the position coordinate vs time. Individual lines represent individual objects (such as cells). Lines are coloured by collective event id. On hover, shows the collective event id, and on click takes the user to the first frame of the selected collective event and marks this event with a bounding box. The dropdown allows a choice of projection axis.</p> </li> </ul> <p>3. By clicking on this button the plot is opened as a popup window that can be freely resized. By closing this popup window the plot is readded to the widget.</p>"},{"location":"Usage/#export","title":"Export","text":"<p>In this tab various options for exporting output are available.</p> <p></p> <p>1. The data generated by Arcos can be exported as a CSV file. \"Export ARCOS Data\" will save a CSV file containing the input data appended with a column containing tracks for collective events. \"Export ARCOS Statistics\" will save a CSV file containing some basic collective event statistics such as average duration, starting point, endpoint</p> <p>2. The layers generated by ARCOS can be exported as a sequence of screenshots. The checkbox \"Try to adjust Viewer\" will try to fit the data in the viewer to the specified size. This is an experimental feature and will likely not work for 3D data and not for either very large or very small dimensions since the viewer has limits on how small/ how large it can get. These depend on the actual screen size.</p> <p>3. \"Export Parameters\" will save a yaml file containing the parameters used for detecting collective events aswell as general widget settings such as file names and columnames. \"Import Parameters\" will load a yaml file containing the parameters used for detecting collective events aswell as general widget settings such as file names and columnames. What is imported can be selected in the popup dialogue. When columns or file name are imported, the widget resets all attributes to the imported values. This means that the current state of the widget is lost. This is done to ensure that the widget is in a consistent state after importing. Data is also reset.</p> <p>4. Batch processing allows to run ARCOS on multiple files. Batch processing will run ARCOS on all csv files in the folder and if postion and or additional filters are set, it will iterate over all combinations in the file and produce one output per combination. The output files will be saved in the same folder as the input files. What is saved can be selected in the popup dialogue.</p>"},{"location":"Usage/#arcos-parameters","title":"ARCOS parameters","text":""},{"location":"Usage/#measurement","title":"Measurement","text":"Parameters Description Interpolate Measurements If the tickbox is checked, missing values are interpolated across all columns in the input data Clip Measurements if the tickbox is checked, the measurement will be clippedaccording to the quantiles provided in clip low and clip high Clip Low appears if clip measurements is checked Clip High appears if clip measurements is checked"},{"location":"Usage/#binarization","title":"Binarization","text":"Parameter Description Bias Method Choose de-trending method, can be runmed, lm or none Smooth K Size of the short-term median smoothing filter. Bias K Available if Bias Method is set to 'runmed', size of long-term median smoothing filter polyDeg Available if Bias Method is set to 'lm',sets the degree of the polynomial for regression detrending Bin Peak Threshold Threshold for rescaling of the de-trended signal. <p>First, a short-term median filter with size smoothK is applied to remove fast noise from the time series. If the Bias Method is set to \"none\", smoothing is applied to globally rescaled time series. The subsequent de-trending can be performed with a long-term median filter with the size biasK {biasMet = \"runmed\"} or by fitting a polynomial of degree polyDeg {biasMet = \"lm\"}. After de-trending, if the global difference between min/max is greater than the threshold the signal is rescaled to the (0,1) range. The final signal is binarised using the binThr threshold parameter.</p>"},{"location":"Usage/#collective-event-detection","title":"Collective Event Detection","text":"Parameter Description Neighbourhood Size The maximum distance between two samples for one to be consideredas in the neighbourhood of the other. This is not a maximum bound on the distances of points within a cluster. Value is also used to connect collective events across multiple frames. Min Clustersize Minimum size for a cluster to be identified as a collective nPrev frames Number of previous frames to consider when tracking collective_events"},{"location":"Usage/#filter-collective-events","title":"Filter Collective Events","text":"Parameter Description Min Duration Minimal duration of collective events to be selected. Total Event Size Minimal total event size."},{"location":"Usage/#additional","title":"Additional","text":"<p>Add Binarized Cell layer: If checked, the binarized cell layer is added to the viewer. This can be useful to check if the binarization step worked as expected. Add all Cells layer: If checked, the all cells layer is added to the viewer. This can be useful to check if measurements are as expected. Add Convex Hull: If checked, the convex hull is calculated for each collective event and drawn in 2d as polygons, and in 3d as surfaces. If a large amount of collective events are detected, adding polygons/surfaces can take some time. Output Axis Order: The output axis order of the layers generated. Can be any order of \"tzyx\", where z is option. If z is not present, the layers will be 2D. If z is present, the layers will be 3D and if the input data is 2d, the z axis will be set to 1. Useful for compatibility with other napari plugins.</p>"},{"location":"Usage/#sample-data","title":"Sample Data","text":"<p>Sample data can be found under the napari sample-data menu (Toolbar: File.. Open Sample.. arcos-gui..). Two datasets are provided: - A synthetically generated dataset of an expanding wave, the measurement is provided as binary values. - A real dataset of a collective event triggered after an apoptotic event. Data is taken from an MDCK epithelium expressing an ERK FRET probe (dataset from Paolo Gagliardi). A good binary threshold value for this dataset is 0.5. Will also try to download the corresponding time-series.</p>"},{"location":"Usage/#using-arcos-in-a-jupyter-notebook","title":"Using ARCOS in a jupyter notebook","text":"<p>to use ARCOS in a jupyter notebook, you can import various functions from the arcos_gui module:</p> <pre><code>from napari import Viewer\nfrom arcos_gui import (\n    filter_data,\n    get_arcos_output,\n    load_dataframe,\n    load_dataframe_with_columnpicker,\n    load_sample_data,\n    open_plugin,\n    run_arcos,\n    run_binarization_only,\n    get_current_arcos_plugin,\n)\n\n# open the plugin\nviewer = Viewer()\nplugin = open_widget(viewer)\n\n# load data\ndata: pd.DataFrame\nload_dataframe(plugin, data, **parameters)\nrun_arcos(plugin, **parameters)\n\n# or load data with column picker\ndata: pd.DataFrame\nload_dataframe_with_columnpicker(plugin, data) # will open a column picker dialogue to selecte columns\n\n# to then get the output\noutput = get_arcos_output(plugin)\n\n# you can also access the data and parameters stored in the plugin\nplugin.data.original_data.value # original data\nplugin.data.filtered_data.value # filtered data\nplugin.data.arcos_parameters.interpolate_meas.value # example parameter\n\n# or connect custom events to the plugin\nplugin.data.arcos_output.value_changed.connect(my_custom_function)\n\n# to export parameters you can use the export_to_yaml method of the data object\nplugin.data.export_to_yaml(\"path/to/file.yaml\")\n\n# to load parameters you can use the import_from_yaml method of the data object\nplugin.data.import_from_yaml(\"path/to/file.yaml\")\n\n# check function docstrings for more details\n\n# if the plugin is already open you can either get the plugin instance with\nplugin = get_current_arcos_plugin()\n</code></pre>"},{"location":"Usage/#batch-processing","title":"Batch Processing","text":"<p>Batch processing allows to run ARCOS on multiple files. Batch processing will run ARCOS on all csv files in the folder and if postion and or additional filters are set, it will iterate over all combinations in the file and produce one output per combination. The output files will be saved in the same folder as the input files. What is saved can be selected in the popup dialogue. To run batch processing go to the Export tab and click the corresponding button.</p>"}]}